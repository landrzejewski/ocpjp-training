<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Concurrency</title>
    <link rel="stylesheet" href="styles.css"/>
</head>
<body>
<div class="container">
    <div class="test">
        <p class="timer">00:00:00</p>

        <div class="question" data-question="1">
            <h1 class="question-title">Question 1</h1>
            <p class="question-text">Given the following code snippet, which options correctly create a parallel stream? (Choose all that apply.)</p>
            <pre class="question-code">
var c = new ArrayList&lt;Thread&gt;();
var s = c.stream();
var p = _________________;
</pre>
            <div class="question-answers">
                <p class="question-answer" data-is-correct="False"><input name="A" type="checkbox"/>A. new ParallelStream(s)</p>
                <p class="question-answer" data-is-correct="False"><input name="B" type="checkbox"/>B. c.parallel()</p>
                <p class="question-answer" data-is-correct="False"><input name="C" type="checkbox"/>C. s.parallelStream()</p>
                <p class="question-answer" data-is-correct="True"><input name="D" type="checkbox"/>D. c.parallelStream()</p>
                <p class="question-answer" data-is-correct="False"><input name="E" type="checkbox"/>E. new ParallelStream(c)</p>
                <p class="question-answer" data-is-correct="True"><input name="F" type="checkbox"/>F. s.parallel()</p>
            </div>
            <p class="question-explanation">
                D, F. There is no such class within the Java API called ParallelStream, so options A and
                E are incorrect. The method defined in the Stream class to create a parallel stream from
                an existing stream is parallel(); therefore, option F is correct, and option C is incorrect.
                The method defined in the Collection class to create a parallel stream from a collection is
                parallelStream(); therefore, option D is correct, and option B is incorrect.
            </p>
        </div>
        <div class="question" data-question="2">
            <h1 class="question-title">Question 2</h1>
            <p class="question-text">Given that the sum of the numbers from 1 (inclusive) to 10 (exclusive) is 45, what are the possible
                results of executing the following program? (Choose all that apply.)</p>
            <pre class="question-code">
1:  import java.util.concurrent.locks.*;
2:  import java.util.stream.*;
3:  public class Bank {
4:     private Lock vault = new ReentrantLock();
5:     private int total = 0;
6:     public void deposit(int value) {
7:        try {
8:           vault.tryLock();
9:           total += value;
10:       } finally { vault.unlock(); }
11:    }
12:    public static void main(String[] unused) {
13:       var bank = new Bank();
14:       IntStream.range(1, 10).parallel()
15:          .forEach(s -&gt; bank.deposit(s));
16:       System.out.println(bank.total);
17:    } }
</pre>
            <div class="question-answers">
                <p class="question-answer" data-is-correct="True"><input name="A" type="checkbox"/>A. 45 is printed.</p>
                <p class="question-answer" data-is-correct="False"><input name="B" type="checkbox"/>B. A number less than 45 is printed.</p>
                <p class="question-answer" data-is-correct="False"><input name="C" type="checkbox"/>C. A number greater than 45 is printed.</p>
                <p class="question-answer" data-is-correct="True"><input name="D" type="checkbox"/>D. An exception is thrown.</p>
                <p class="question-answer" data-is-correct="False"><input name="E" type="checkbox"/>E. None of the above, as the code does not compile.</p>
            </div>
            <p class="question-explanation">
                A, D. The tryLock() method returns immediately with a value of false if the lock cannot
                be acquired. Unlike lock(), it does not wait for a lock to become available. This code fails
                to check the return value on line 8, resulting in the protected code being entered regardless of
                whether the lock is obtained. In some executions (when tryLock() returns true on every
                call), the code will complete successfully and print 45 at runtime, making option A correct.
                On other executions (when tryLock() returns false at least once), the unlock()
                method on line 10 will throw an IllegalMonitorStateException at runtime, making
                option D correct. Option B would be possible if line 10 did not throw an exception.
            </p>
        </div>
        <div class="question" data-question="3">
            <h1 class="question-title">Question 3</h1>
            <p class="question-text">Which of the following statements about the Callable call() and Runnable run() methods are correct? (Choose all that apply.)</p>
            <pre class="question-code">
</pre>
            <div class="question-answers">
                <p class="question-answer" data-is-correct="False"><input name="A" type="checkbox"/>A. Both methods return void.</p>
                <p class="question-answer" data-is-correct="True"><input name="B" type="checkbox"/>B. Both can throw unchecked exceptions.</p>
                <p class="question-answer" data-is-correct="True"><input name="C" type="checkbox"/>C. Both can be implemented with lambda expressions.</p>
                <p class="question-answer" data-is-correct="False"><input name="D" type="checkbox"/>D. Runnable returns a generic type.</p>
                <p class="question-answer" data-is-correct="False"><input name="E" type="checkbox"/>E. Both can throw checked exceptions.</p>
                <p class="question-answer" data-is-correct="True"><input name="F" type="checkbox"/>F. Callable returns a generic type.</p>
            </div>
            <p class="question-explanation">
                B, C, F. Runnable returns void and Callable returns a generic type, making options A
                and D incorrect and option F correct. All methods are capable of throwing unchecked exceptions,
                so option B is correct. Only Callable is capable of throwing checked exceptions, so
                option E is incorrect. Both Runnable and Callable are functional interfaces that can be
                implemented with a lambda expression, so option C is also correct.
            </p>
        </div>
        <div class="question" data-question="4">
            <h1 class="question-title">Question 4</h1>
            <p class="question-text">Which lines need to be changed to make the code compile? (Choose all that apply.)</p>
            <pre class="question-code">
ExecutorService service =   // w1
  Executors.newSingleThreadScheduledExecutor();
service.scheduleWithFixedDelay(() -&gt; {
  System.out.println("Open Zoo");
  return null;   // w2
}, 0, 1, TimeUnit.MINUTES);
var result = service.submit(() -&gt;   // w3
  System.out.println("Wake Staff"));
System.out.println(result.get());   // w4
</pre>
            <div class="question-answers">
                <p class="question-answer" data-is-correct="False"><input name="A" type="checkbox"/>A. It compiles and runs without issue.</p>
                <p class="question-answer" data-is-correct="True"><input name="B" type="checkbox"/>B. Line w1</p>
                <p class="question-answer" data-is-correct="True"><input name="C" type="checkbox"/>C. Line w2</p>
                <p class="question-answer" data-is-correct="False"><input name="D" type="checkbox"/>D. Line w3</p>
                <p class="question-answer" data-is-correct="False"><input name="E" type="checkbox"/>E. Line w4</p>
                <p class="question-answer" data-is-correct="False"><input name="F" type="checkbox"/>F. It compiles but throws an exception at runtime.</p>
            </div>
            <p class="question-explanation">
                B, C. The code does not compile, so options A and F are incorrect. The first problem
                is that although a ScheduledExecutorService is created, it is assigned to an
                ExecutorService. The type of the variable on line w1 would have to be updated to
                ScheduledExecutorService for the code to compile, making option B correct. The
                second problem is that scheduleWithFixedDelay() supports only Runnable, not
                Callable, and any attempt to return a value is invalid in a Runnable lambda expression;
                therefore, line w2 will also not compile, and option C is correct. The rest of the lines compile
                without issue, so options D and E are incorrect.
            </p>
        </div>
        <div class="question" data-question="5">
            <h1 class="question-title">Question 5</h1>
            <p class="question-text">What statement about the following code is true?</p>
            <pre class="question-code">
var value1 = new AtomicLong(0);
final long[] value2 = {0};
IntStream.iterate(1, i -&gt; 1).limit(100).parallel()
  .forEach(i -&gt; value1.incrementAndGet());
IntStream.iterate(1, i -&gt; 1).limit(100).parallel()
  .forEach(i -&gt; ++value2[0]);
System.out.println(value1+" "+value2[0]);
</pre>
            <div class="question-answers">
                <p class="question-answer" data-is-correct="False"><input name="A" type="checkbox"/>A. It outputs 100 100.</p>
                <p class="question-answer" data-is-correct="False"><input name="B" type="checkbox"/>B. It outputs 100 99.</p>
                <p class="question-answer" data-is-correct="True"><input name="C" type="checkbox"/>C. The output cannot be determined ahead of time.</p>
                <p class="question-answer" data-is-correct="False"><input name="D" type="checkbox"/>D. The code does not compile.</p>
                <p class="question-answer" data-is-correct="False"><input name="E" type="checkbox"/>E. It compiles but throws an exception at runtime.</p>
                <p class="question-answer" data-is-correct="False"><input name="F" type="checkbox"/>F. It compiles but enters an infinite loop at runtime.</p>
                <p class="question-answer" data-is-correct="False"><input name="G" type="checkbox"/>G. None of the above</p>
            </div>
            <p class="question-explanation">
                C. The code compiles and runs without throwing an exception or entering an infinite loop,
                so options D, E, and F are incorrect. The key here is that the increment operator ++ is not
                atomic. While the first part of the output will always be 100, the second part is nondeterministic.
                It may output any value from 1 to 100, because the threads can overwrite each other’s
                work. Therefore, option C is the correct answer, and options A and B are incorrect.
            </p>
        </div>
        <div class="question" data-question="6">
            <h1 class="question-title">Question 6</h1>
            <p class="question-text">Which statements about the following code are correct? (Choose all that apply.)</p>
            <pre class="question-code">
var data = List.of(2,5,1,9,8);
data.stream().parallel()
  .mapToInt(s -&gt; s)
  .peek(System.out::print)
  .forEachOrdered(System.out::print);
</pre>
            <div class="question-answers">
                <p class="question-answer" data-is-correct="False"><input name="A" type="checkbox"/>A. The peek() method will print the entries in the sorted order: 12589.</p>
                <p class="question-answer" data-is-correct="False"><input name="B" type="checkbox"/>B. The peek() method will print the entries in the original order: 25198.</p>
                <p class="question-answer" data-is-correct="True"><input name="C" type="checkbox"/>C. The peek() method will print the entries in an order that cannot be determined ahead of time.</p>
                <p class="question-answer" data-is-correct="False"><input name="D" type="checkbox"/>D. The forEachOrdered() method will print the entries in the sorted order: 12589.</p>
                <p class="question-answer" data-is-correct="True"><input name="E" type="checkbox"/>E. The forEachOrdered() method will print the entries in the original order: 25198.</p>
                <p class="question-answer" data-is-correct="False"><input name="F" type="checkbox"/>F. The forEachOrdered() method will print the entries in an order that cannot be determined ahead of time.</p>
                <p class="question-answer" data-is-correct="False"><input name="G" type="checkbox"/>G. The code does not compile.</p>
            </div>
            <p class="question-explanation">
                C, E. The code compiles, so option G is incorrect. The peek() method on a parallel stream
                will process the elements concurrently, so the order cannot be determined ahead of time, and
                option C is correct. The forEachOrdered() method will process the elements in the order
                in which they are stored in the stream, making option E correct. None of the methods sort
                the elements, so options A and D are incorrect.
            </p>
        </div>
        <div class="question" data-question="7">
            <h1 class="question-title">Question 7</h1>
            <p class="question-text">Fill in the blanks: __________ occur(s) when two or more threads are blocked forever but both appear
                active. _______ occur(s) when two or more threads try to complete a related task at the same time, resulting in invalid or unexpected data.</p>
            <pre class="question-code">
</pre>
            <div class="question-answers">
                <p class="question-answer" data-is-correct="False"><input name="A" type="checkbox"/>A. Livelock, Deadlock</p>
                <p class="question-answer" data-is-correct="False"><input name="B" type="checkbox"/>B. Deadlock, Starvation</p>
                <p class="question-answer" data-is-correct="False"><input name="C" type="checkbox"/>C. Race conditions, Deadlock</p>
                <p class="question-answer" data-is-correct="True"><input name="D" type="checkbox"/>D. Livelock, Race conditions</p>
                <p class="question-answer" data-is-correct="False"><input name="E" type="checkbox"/>E. Starvation, Race conditions</p>
                <p class="question-answer" data-is-correct="False"><input name="F" type="checkbox"/>F. Deadlock, Livelock</p>
            </div>
            <p class="question-explanation">
                D. Livelock occurs when two or more threads are conceptually blocked forever, although
                they are each still active and trying to complete their task. A race condition is an undesirable
                result that occurs when two tasks that should have been completed sequentially are completed at the same time.
                For these reasons, option D is correct
            </p>
        </div>
        <div class="question" data-question="8">
            <h1 class="question-title">Question 8</h1>
            <p class="question-text">Assuming this class is accessed by only a single thread at a time, what is the result of calling the countIceCreamFlavors() method?</p>
            <pre class="question-code">
import java.util.stream.LongStream;
public class Flavors {
  private static int counter;
  public static void countIceCreamFlavors()  {
    counter = 0;
    Runnable task = () -&gt; counter++;
    LongStream.range(0, 500)
      .forEach(m -&gt; new Thread(task).run());
    System.out.println(counter);
} }
</pre>
            <div class="question-answers">
                <p class="question-answer" data-is-correct="False"><input name="A" type="checkbox"/>A. The method consistently prints a number less than 500.</p>
                <p class="question-answer" data-is-correct="True"><input name="B" type="checkbox"/>B. The method consistently prints 500.</p>
                <p class="question-answer" data-is-correct="False"><input name="C" type="checkbox"/>C. The method compiles and prints a value, but that value cannot be determined ahead of time.</p>
                <p class="question-answer" data-is-correct="False"><input name="D" type="checkbox"/>D. The method does not compile.</p>
                <p class="question-answer" data-is-correct="False"><input name="E" type="checkbox"/>E. The method compiles but throws an exception at runtime.</p>
                <p class="question-answer" data-is-correct="False"><input name="F" type="checkbox"/>F. None of the above</p>
            </div>
            <p class="question-explanation">
                B. Be wary of run() vs. start() on the exam! The method looks like it executes a task
                concurrently, but it runs synchronously. In each iteration of the forEach() loop, the process waits for the run()
                method to complete before moving on. For this reason, the code
                is thread-safe. Since the program consistently prints 500 at runtime, option B is correct.
                Note that if start() had been used instead of run() (or the stream was parallel), then the
                output would be indeterminate, and option C would have been correct.
            </p>
        </div>
        <div class="question" data-question="9">
            <h1 class="question-title">Question 9</h1>
            <p class="question-text">Which happens when a new task is submitted to an ExecutorService in which no threads are available?</p>
            <pre class="question-code">
</pre>
            <div class="question-answers">
                <p class="question-answer" data-is-correct="False"><input name="A" type="checkbox"/>A. The executor throws an exception when the task is submitted.</p>
                <p class="question-answer" data-is-correct="False"><input name="B" type="checkbox"/>B. The executor discards the task without completing it.</p>
                <p class="question-answer" data-is-correct="True"><input name="C" type="checkbox"/>C. The executor adds the task to an internal queue and completes when there is an available thread.</p>
                <p class="question-answer" data-is-correct="False"><input name="D" type="checkbox"/>D. The thread submitting the task waits on the submit call until a thread is available before continuing.</p>
                <p class="question-answer" data-is-correct="False"><input name="E" type="checkbox"/>E. The executor stops an existing task and starts the newly submitted one.</p>
            </div>
            <p class="question-explanation">
                C. If a task is submitted to a thread executor, and the thread executor does not have any
                available threads, the call to the task will return immediately with the task being queued
                internally by the thread executor. For this reason, option C is the correct answer.
            </p>
        </div>
        <div class="question" data-question="10">
            <h1 class="question-title">Question 10</h1>
            <p class="question-text">What is the result of executing the following code snippet?</p>
            <pre class="question-code">
List&lt;Integer&gt; lions = new ArrayList&lt;&gt;(List.of(1,2,3));
List&lt;Integer&gt; tigers = new CopyOnWriteArrayList&lt;&gt;(lions);
Set&lt;Integer&gt; bears = new ConcurrentSkipListSet&lt;&gt;();
bears.addAll(lions);
for(Integer item: tigers) tigers.add(4); // x1
for(Integer item: bears) bears.add(5);   // x2
System.out.println(lions.size() + " " + tigers.size()
  + " " + bears.size());
</pre>
            <div class="question-answers">
                <p class="question-answer" data-is-correct="True"><input name="A" type="checkbox"/>A. It outputs 3 6 4.</p>
                <p class="question-answer" data-is-correct="False"><input name="B" type="checkbox"/>B. It outputs 6 6 6.</p>
                <p class="question-answer" data-is-correct="False"><input name="C" type="checkbox"/>C. It outputs 6 3 4.</p>
                <p class="question-answer" data-is-correct="False"><input name="D" type="checkbox"/>D. The code does not compile.</p>
                <p class="question-answer" data-is-correct="False"><input name="E" type="checkbox"/>E. It compiles but throws an exception at runtime on line x1.</p>
                <p class="question-answer" data-is-correct="False"><input name="F" type="checkbox"/>F. It compiles but throws an exception at runtime on line x2.</p>
                <p class="question-answer" data-is-correct="False"><input name="G" type="checkbox"/>G. It compiles but enters an infinite loop at runtime.</p>
            </div>
            <p class="question-explanation">
                A. The code compiles without issue, so option D is incorrect. The
                CopyOnWriteArrrayList class is designed to preserve the original list on iteration, so
                the first loop will be executed exactly three times and, in the process, will increase the size of
                tigers to six elements. The ConcurrentSkipListSet class allows modifications, and
                since it enforces the uniqueness of its elements, the value 5 is added only once, leading to a
                total of four elements in bears. Finally, despite using the elements of lions to populate
                the collections, tigers and bears are not backed by the original list, so the size of lions
                is 3 throughout this program. For these reasons, the program prints 3 6 4, and option A
                is correct.
            </p>
        </div>
        <div class="question" data-question="11">
            <h1 class="question-title">Question 11</h1>
            <p class="question-text">What statements about the following code are true? (Choose all that apply.)</p>
            <pre class="question-code">
Integer i1 = List.of(1, 2, 3, 4, 5).stream().findAny().get();
synchronized(i1) { // y1
  Integer i2 = List.of(6, 7, 8, 9, 10)
    .parallelStream()
    .sorted()
    .findAny().get(); // y2
    System.out.println(i1 + " " + i2);
}
</pre>
            <div class="question-answers">
                <p class="question-answer" data-is-correct="False"><input name="A" type="checkbox"/>A. The first value printed is always 1.</p>
                <p class="question-answer" data-is-correct="False"><input name="B" type="checkbox"/>B. The second value printed is always 6.</p>
                <p class="question-answer" data-is-correct="False"><input name="C" type="checkbox"/>C. The code will not compile because of line y1.</p>
                <p class="question-answer" data-is-correct="False"><input name="D" type="checkbox"/>D. The code will not compile because of line y2.</p>
                <p class="question-answer" data-is-correct="False"><input name="E" type="checkbox"/>E. The code compiles but throws an exception at runtime.</p>
                <p class="question-answer" data-is-correct="True"><input name="F" type="checkbox"/>F. The output cannot be determined ahead of time.</p>
                <p class="question-answer" data-is-correct="False"><input name="G" type="checkbox"/>G. It compiles but waits forever at runtime.</p>
            </div>
            <p class="question-explanation">
                F. The code compiles and runs without issue, so options C, D, E, and G are incorrect.
                There are two important things to notice. First, synchronizing on the first variable doesn’t
                impact the results of the code. Second, sorting on a parallel stream does not mean that
                findAny() will return the first record. The findAny() method will return the value from
                the first thread that retrieves a record. Therefore, the output is not guaranteed, and option
                F is correct. Option A looks correct, but even on serial streams, findAny() is free to select
                any element.
            </p>
        </div>
        <div class="question" data-question="12">
            <h1 class="question-title">Question 12</h1>
            <p class="question-text">Assuming each call to takeNap() takes five seconds to execute without throwing an exception, what is the expected
                result of executing the following code snippet?</p>
            <pre class="question-code">
ExecutorService service = Executors.newFixedThreadPool(4);
try {
  service.execute(() -&gt; takeNap());
  service.execute(() -&gt; takeNap());
  service.execute(() -&gt; takeNap());
} finally {
  service.shutdown();
}
service.awaitTermination(2, TimeUnit.SECONDS);
System.out.println("DONE!");
</pre>
            <div class="question-answers">
                <p class="question-answer" data-is-correct="False"><input name="A" type="checkbox"/>A. It will immediately print DONE!.</p>
                <p class="question-answer" data-is-correct="True"><input name="B" type="checkbox"/>B. It will pause for 2 seconds and then print DONE!.</p>
                <p class="question-answer" data-is-correct="False"><input name="C" type="checkbox"/>C. It will pause for 5 seconds and then print DONE!.</p>
                <p class="question-answer" data-is-correct="False"><input name="D" type="checkbox"/>D. It will pause for 15 seconds and then print DONE!.</p>
                <p class="question-answer" data-is-correct="False"><input name="E" type="checkbox"/>E. It will throw an exception at runtime.</p>
                <p class="question-answer" data-is-correct="False"><input name="F" type="checkbox"/>F. None of the above, as the code does not compile.</p>
            </div>
            <p class="question-explanation">
                B. The code snippet submits three tasks to an ExecutorService, shuts it down, and then
                waits for the results. The awaitTermination() method waits a specified amount of time
                for all tasks to complete and the service to finish shutting down. Since each five-second task
                is still executing, the awaitTermination() method will return with a value of false
                after two seconds but not throw an exception. For these reasons, option B is correct.
            </p>
        </div>
        <div class="question" data-question="13">
            <h1 class="question-title">Question 13</h1>
            <p class="question-text">What statements about the following code are true? (Choose all that apply.)</p>
            <pre class="question-code">
System.out.print(List.of("duck","flamingo","pelican")
  .parallelStream().parallel()   // q1
  .reduce(0,
    (c1, c2) -&gt; c1.length() + c2.length(),  // q2
    (s1, s2) -&gt; s1 + s2));      // q3
</pre>
            <div class="question-answers">
                <p class="question-answer" data-is-correct="False"><input name="A" type="checkbox"/>A. It compiles and runs without issue, outputting the total length of all strings in the stream.</p>
                <p class="question-answer" data-is-correct="False"><input name="B" type="checkbox"/>B. The code will not compile because of line q1.</p>
                <p class="question-answer" data-is-correct="True"><input name="C" type="checkbox"/>C. The code will not compile because of line q2.</p>
                <p class="question-answer" data-is-correct="False"><input name="D" type="checkbox"/>D. The code will not compile because of line q3.</p>
                <p class="question-answer" data-is-correct="False"><input name="E" type="checkbox"/>E. It compiles but throws an exception at runtime.</p>
                <p class="question-answer" data-is-correct="False"><input name="F" type="checkbox"/>F. None of the above</p>
            </div>
            <p class="question-explanation">
                C. The code does not compile, so options A and E are incorrect. The problem here is that
                c1 is an Integer and c2 is a String, so the code fails to combine on line q2, since calling
                length() on an Integer is not allowed, and option C is correct. The rest of the lines compile without issue.
                Note that calling parallel() on an already parallel stream is allowed,
                and it may return the same object.
            </p>
        </div>
        <div class="question" data-question="14">
            <h1 class="question-title">Question 14</h1>
            <p class="question-text">What statements about the following code snippet are true? (Choose all that apply.)</p>
            <pre class="question-code">
Object o1 = new Object();
Object o2 = new Object();
var service = Executors.newFixedThreadPool(2);
var f1 = service.submit(() -&gt; {
  synchronized (o1) {
  synchronized (o2) { System.out.print("Tortoise"); }
}
});
var f2 = service.submit(() -&gt; {
  synchronized (o2) {
  synchronized (o1) { System.out.print("Hare"); }
}
});
f1.get();
f2.get();
</pre>
            <div class="question-answers">
                <p class="question-answer" data-is-correct="False"><input name="A" type="checkbox"/>A. The code will always output Tortoise followed by Hare.</p>
                <p class="question-answer" data-is-correct="False"><input name="B" type="checkbox"/>B. The code will always output Hare followed by Tortoise.</p>
                <p class="question-answer" data-is-correct="True"><input name="C" type="checkbox"/>C. If the code does output anything, the order cannot be determined.</p>
                <p class="question-answer" data-is-correct="False"><input name="D" type="checkbox"/>D. The code does not compile.</p>
                <p class="question-answer" data-is-correct="True"><input name="E" type="checkbox"/>E. The code compiles but may produce a deadlock at runtime.</p>
                <p class="question-answer" data-is-correct="False"><input name="F" type="checkbox"/>F. The code compiles but may produce a livelock at runtime.</p>
                <p class="question-answer" data-is-correct="False"><input name="G" type="checkbox"/>G. It compiles but throws an exception at runtime.</p>
            </div>
            <p class="question-explanation">
                C, E. The code compiles without issue, so option D is incorrect. Since both tasks are submitted to the same thread
                executor pool, the order cannot be determined, so options A and
                B are incorrect, and option C is correct. The key here is that the order in which the resources
                o1 and o2 are synchronized could result in a deadlock. For example, if the first thread gets a
                lock on o1 and the second thread gets a lock on o2 before either thread can get their second
                lock, the code will hang at runtime, making option E correct. The code cannot produce a
                livelock, since both threads are waiting, so option F is incorrect. Finally, if a deadlock does
                occur, an exception will not be thrown, so option G is incorrect.
            </p>
        </div>
        <div class="question" data-question="15">
            <h1 class="question-title">Question 15</h1>
            <p class="question-text">Which statement about the following code snippet is correct?</p>
            <pre class="question-code">
2: var cats = Stream.of("leopard", "lynx", "ocelot", "puma")
3:    .parallel();
4: var bears = Stream.of("panda","grizzly","polar").parallel();
5: var data = Stream.of(cats,bears).flatMap(s -&gt; s)
6:    .collect(Collectors.groupingByConcurrent(
7:       s -&gt; !s.startsWith("p")));
8: System.out.println(data.get(false).size()
9:    + " " + data.get(true).size());
</pre>
            <div class="question-answers">
                <p class="question-answer" data-is-correct="True"><input name="A" type="checkbox"/>A. It outputs 3 4.</p>
                <p class="question-answer" data-is-correct="False"><input name="B" type="checkbox"/>B. It outputs 4 3.</p>
                <p class="question-answer" data-is-correct="False"><input name="C" type="checkbox"/>C. The code will not compile because of line 6.</p>
                <p class="question-answer" data-is-correct="False"><input name="D" type="checkbox"/>D. The code will not compile because of line 7.</p>
                <p class="question-answer" data-is-correct="False"><input name="E" type="checkbox"/>E. The code will not compile because of line 8.</p>
                <p class="question-answer" data-is-correct="False"><input name="F" type="checkbox"/>F. It compiles but throws an exception at runtime.</p>
            </div>
            <p class="question-explanation">
                A. The code compiles and runs without issue, so options C, D, E, and F are incorrect. The
                collect() operation groups the animals into those that do and do not start with the letter
                p. Note that there are four animals that do not start with the letter p and three animals that
                do. The logical complement operator (!) before the startsWith() method means that
                results are reversed, so the output is 3 4, and option A is correct, making option B incorrect.
            </p>
        </div>
        <div class="question" data-question="16">
            <h1 class="question-title">Question 16</h1>
            <p class="question-text">Assuming one minute is enough time for all the threads within this program to complete, what are the possible
                results of executing the following program? (Choose all that apply.)</p>
            <pre class="question-code">
public class RocketShip {
  private volatile int fuel;
  private void launch(int checks) {
    var p = new ArrayList&lt;Thread&gt;();
    for (int i = 0; i &lt; checks; i++)
    p.add(new Thread(() -&gt; fuel++));
    p.forEach(Thread::interrupt);
    p.forEach(Thread::start);
    p.forEach(Thread::interrupt);
  }
  public static void main(String[] args) throws Exception {
    var ship = new RocketShip();
    ship.launch(100);
    Thread.sleep(60*1000);
    System.out.print(ship.fuel);
} }
</pre>
            <div class="question-answers">
                <p class="question-answer" data-is-correct="True"><input name="A" type="checkbox"/>A. It prints a number less than 100.</p>
                <p class="question-answer" data-is-correct="True"><input name="B" type="checkbox"/>B. It prints 100.</p>
                <p class="question-answer" data-is-correct="False"><input name="C" type="checkbox"/>C. It prints a number greater than 100.</p>
                <p class="question-answer" data-is-correct="False"><input name="D" type="checkbox"/>D. It does not compile.</p>
                <p class="question-answer" data-is-correct="False"><input name="E" type="checkbox"/>E. It compiles but throws an InterruptedException at runtime.</p>
            </div>
            <p class="question-explanation">
                A, B. The code compiles just fine. If the calls to fuel++ are ordered sequentially, then the
                program will print 100 at runtime, making option B correct. On the other hand, the calls
                may overwrite each other. The volatile attribute only guarantees memory consistency, not
                thread-safety, making option A correct and option C incorrect. Option E is also incorrect,
                as no InterruptedException is thrown by this code. Remember, interrupt() only
                impacts a thread that is in a WAITING or TIMED_WAITING state. Calling interrupt() on
                a thread in a NEW or RUNNABLE state has no impact unless the code is running and explicitly
                checking the isInterrupted() method.
            </p>
        </div>
        <div class="question" data-question="17">
            <h1 class="question-title">Question 17</h1>
            <p class="question-text">Which statements about methods in ReentrantLock are correct? (Choose all that apply.)</p>
            <pre class="question-code">
</pre>
            <div class="question-answers">
                <p class="question-answer" data-is-correct="False"><input name="A" type="checkbox"/>A. The lock() method will attempt to acquire a lock without waiting indefinitely for it.</p>
                <p class="question-answer" data-is-correct="False"><input name="B" type="checkbox"/>B. The testLock() method will attempt to acquire a lock without waiting indefinitely for it.</p>
                <p class="question-answer" data-is-correct="False"><input name="C" type="checkbox"/>C. The attemptLock() method will attempt to acquire a lock without waiting indefinitely for it.</p>
                <p class="question-answer" data-is-correct="False"><input name="D" type="checkbox"/>D. By default, a ReentrantLock fairly releases to each thread in the order in which it was requested.</p>
                <p class="question-answer" data-is-correct="False"><input name="E" type="checkbox"/>E. Calling the unlock() method once will release a resource so that other threads can obtain the lock.</p>
                <p class="question-answer" data-is-correct="True"><input name="F" type="checkbox"/>F. None of the above</p>
            </div>
            <p class="question-explanation">
                F. The lock() method will wait indefinitely for a lock, so option A is incorrect. Options B
                and C are also incorrect, as the correct method name to attempt to acquire a lock is
                tryLock(). Option D is incorrect, as fairness is set to false by default and must be
                enabled by using an overloaded constructor. Finally, option E is incorrect because a thread
                that holds the lock may have called lock() or tryLock() multiple times. A thread needs
                to call unlock() once for each call to lock() and successful tryLock(). Option F is the
                correct answer since none of the other options are valid statements.
            </p>
        </div>
        <div class="question" data-question="18">
            <h1 class="question-title">Question 18</h1>
            <p class="question-text">Which of the following are valid Callable expressions? (Choose all that apply.)</p>
            <pre class="question-code">
</pre>
            <div class="question-answers">
                <p class="question-answer" data-is-correct="False"><input name="A" type="checkbox"/>A. a -&gt; {return 10;}</p>
                <p class="question-answer" data-is-correct="False"><input name="B" type="checkbox"/>B. () -&gt; {String s = "";}</p>
                <p class="question-answer" data-is-correct="True"><input name="C" type="checkbox"/>C. () -&gt; 5</p>
                <p class="question-answer" data-is-correct="False"><input name="D" type="checkbox"/>D. () -&gt; {return null}</p>
                <p class="question-answer" data-is-correct="True"><input name="E" type="checkbox"/>E. () -&gt; "The" + "Zoo"</p>
                <p class="question-answer" data-is-correct="False"><input name="F" type="checkbox"/>F. (int count) -&gt; count+1</p>
                <p class="question-answer" data-is-correct="True"><input name="G" type="checkbox"/>G. () -&gt; {System.out.println("Giraffe"); return 10;}</p>
            </div>
            <p class="question-explanation">
                C, E, G. A Callable lambda expression takes no values and returns a generic type; therefore, options C, E,
                and G are correct. Options A and F are incorrect because they both take
                an input parameter. Option B is incorrect because it does not return a value. Option D is not
                a valid lambda expression, because it is missing a semicolon at the end of the return statement, which is required when inside braces {}.
            </p>
        </div>
        <div class="question" data-question="19">
            <h1 class="question-title">Question 19</h1>
            <p class="question-text">What is the result of executing the following application? (Choose all that apply.)</p>
            <pre class="question-code">
import java.util.concurrent.*;
import java.util.stream.*;
public class PrintConstants {
  public static void main(String[] args) {
    var s = Executors.newScheduledThreadPool(10);
    DoubleStream.of(3.14159,2.71828)   // b1
      .forEach(c -&gt; s.submit(         // b2
    () -&gt; System.out.println(10*c)));  // b3
    s.execute(() -&gt; System.out.println("Printed"));
} }
</pre>
            <div class="question-answers">
                <p class="question-answer" data-is-correct="False"><input name="A" type="checkbox"/>A. It compiles and outputs the two numbers followed by Printed.</p>
                <p class="question-answer" data-is-correct="False"><input name="B" type="checkbox"/>B. The code will not compile because of line b1.</p>
                <p class="question-answer" data-is-correct="False"><input name="C" type="checkbox"/>C. The code will not compile because of line b2.</p>
                <p class="question-answer" data-is-correct="False"><input name="D" type="checkbox"/>D. The code will not compile because of line b3.</p>
                <p class="question-answer" data-is-correct="True"><input name="E" type="checkbox"/>E. It compiles, but the output cannot be determined ahead of time.</p>
                <p class="question-answer" data-is-correct="False"><input name="F" type="checkbox"/>F. It compiles but throws an exception at runtime.</p>
                <p class="question-answer" data-is-correct="True"><input name="G" type="checkbox"/>G. It compiles but waits forever at runtime.</p>
            </div>
            <p class="question-explanation">
                E, G. The application compiles and does not throw an exception. Even though the stream
                is processed in sequential order, the tasks are submitted to a thread executor, which may
                complete the tasks in any order. Therefore, the output cannot be determined ahead of time,
                and option E is correct. Finally, the thread executor is never shut down; therefore, the code
                will run but never terminate, making option G also correct.
            </p>
        </div>
        <div class="question" data-question="20">
            <h1 class="question-title">Question 20</h1>
            <p class="question-text">What is the result of executing the following program? (Choose all that apply.)</p>
            <pre class="question-code">
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.*;
public class PrintCounter {
static int count = 0;
public static void main(String[] args) throws
InterruptedException, ExecutionException {
var service = Executors.newSingleThreadExecutor();
try {
var r = new ArrayList&lt;Future&lt;?&gt;&gt;();
         IntStream.iterate(0,i -&gt; i+1).limit(5).forEach(
            i -&gt; r.add(service.execute(() -&gt; {count++;})) // n1
         );
         for(Future&lt;?&gt; result : r) {
System.out.print(result.get()+" "); // n2
}
} finally { service.shutdown(); }
} }
</pre>
            <div class="question-answers">
                <p class="question-answer" data-is-correct="False"><input name="A" type="checkbox"/>A. It prints 0 1 2 3 4</p>
                <p class="question-answer" data-is-correct="False"><input name="B" type="checkbox"/>B. It prints 1 2 3 4 5</p>
                <p class="question-answer" data-is-correct="False"><input name="C" type="checkbox"/>C. It prints null null null null null</p>
                <p class="question-answer" data-is-correct="False"><input name="D" type="checkbox"/>D. It hangs indefinitely at runtime.</p>
                <p class="question-answer" data-is-correct="False"><input name="E" type="checkbox"/>E. The output cannot be determined.</p>
                <p class="question-answer" data-is-correct="True"><input name="F" type="checkbox"/>F. The code will not compile because of line n1.</p>
                <p class="question-answer" data-is-correct="False"><input name="G" type="checkbox"/>G. The code will not compile because of line n2.</p>
            </div>
            <p class="question-explanation">
                F. The key to solving this question is to remember that the execute() method returns
                void, not a Future object. Therefore, line n1 does not compile, and option F is the
                correct answer. If the submit() method had been used instead of execute(), option C
                would have been the correct answer, as the output of the submit(Runnable) task is a
                Future&lt;?&gt; object that can only return null on its get() method.
            </p>
        </div>
        <div class="question" data-question="21">
            <h1 class="question-title">Question 21</h1>
            <p class="question-text">Given the following code snippet and blank lines on p1 and p2, which values guarantee that 1 is printed at runtime? (Choose all that apply.)</p>
            <pre class="question-code">
var data = List.of(List.of(1,2),
List.of(3,4),
List.of(5,6));
data.___________    // p1
  .flatMap(s -&gt; s.stream())
.____________    // p2
  .ifPresent(System.out::print);
</pre>
            <div class="question-answers">
                <p class="question-answer" data-is-correct="True"><input name="A" type="checkbox"/>A. stream() on line p1, findFirst() on line p2</p>
                <p class="question-answer" data-is-correct="False"><input name="B" type="checkbox"/>B. stream() on line p1, findAny() on line p2</p>
                <p class="question-answer" data-is-correct="False"><input name="C" type="checkbox"/>C. parallelStream() on line p1, findAny() on line p2</p>
                <p class="question-answer" data-is-correct="True"><input name="D" type="checkbox"/>D. parallelStream() on line p1, findFirst() on line p2</p>
                <p class="question-answer" data-is-correct="False"><input name="E" type="checkbox"/>E. The code does not compile regardless of what is inserted into the blanks.</p>
                <p class="question-answer" data-is-correct="False"><input name="F" type="checkbox"/>F. None of the above</p>
            </div>
            <p class="question-explanation">
                A, D. The findFirst() method guarantees the first element in the stream will be returned,
                whether it is serial or parallel, making options A and D correct. While option B may consistently print 1 at runtime,
                the behavior of findAny() on a serial stream is not guaranteed, so option B is incorrect. Option C is likewise incorrect,
                with the output being random
                at runtime.
            </p>
        </div>
        <div class="question" data-question="22">
            <h1 class="question-title">Question 22</h1>
            <p class="question-text">Assuming one minute is enough time for the tasks submitted to the service executor to complete, what is the result of
                executing countSheep()? (Choose all that apply.)</p>
            <pre class="question-code">
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;
public class BedTime {
private AtomicInteger s1 = new AtomicInteger(0); // w1
private int s2 = 0;
private void countSheep() throws InterruptedException {
var service = Executors.newSingleThreadExecutor(); // w2
try {
  for (int i = 0; i &lt; 100; i++)
  service.execute(() -&gt; {
    s1.getAndIncrement(); s2++; }); // w3
    Thread.sleep(60*1000);
    System.out.println(s1 + " " + s2);
  } finally { service.shutdown(); }
}
public static void main(String… nap) throws InterruptedException {
  new BedTime().countSheep();
} }
</pre>
            <div class="question-answers">
                <p class="question-answer" data-is-correct="False"><input name="A" type="checkbox"/>A. The method consistently prints 100 99.</p>
                <p class="question-answer" data-is-correct="True"><input name="B" type="checkbox"/>B. The method consistently prints 100 100.</p>
                <p class="question-answer" data-is-correct="False"><input name="C" type="checkbox"/>C. The output cannot be determined ahead of time.</p>
                <p class="question-answer" data-is-correct="False"><input name="D" type="checkbox"/>D. The code will not compile because of line w1.</p>
                <p class="question-answer" data-is-correct="False"><input name="E" type="checkbox"/>E. The code will not compile because of line w2.</p>
                <p class="question-answer" data-is-correct="False"><input name="F" type="checkbox"/>F. The code will not compile because of line w3.</p>
                <p class="question-answer" data-is-correct="False"><input name="G" type="checkbox"/>G. It compiles but throws an exception at runtime.</p>
            </div>
            <p class="question-explanation">
                B. The code compiles and runs without issue. The key aspect to notice in the code is that a
                single-thread executor is used, meaning that no task will be executed concurrently. Therefore, the results are valid and
                predictable, with 100 100 being the output, and option B is
                the correct answer. If a thread executor with more threads was used, then the s2++ operations could overwrite each other,
                making the second value indeterminate at the end of the
                program. In this case, option C would be the correct answer.
            </p>
        </div>
        <div class="question" data-question="23">
            <h1 class="question-title">Question 23</h1>
            <p class="question-text">What is the result of executing the following application? (Choose all that apply.)</p>
            <pre class="question-code">
import java.util.concurrent.*;
import java.util.stream.*;
public class StockRoomTracker {
public static void await(CyclicBarrier cb) { // j1
  try { cb.await(); } catch (Exception e) {}
}
public static void main(String[] args) {
  var cb = new CyclicBarrier(10,
  () -&gt; System.out.println("Stock Room Full!")); // j2
  IntStream.iterate(1, i -&gt; 1).limit(9).parallel()
  .forEach(i -&gt; await(cb)); // j3
} }
</pre>
            <div class="question-answers">
                <p class="question-answer" data-is-correct="False"><input name="A" type="checkbox"/>A. It outputs Stock Room Full!</p>
                <p class="question-answer" data-is-correct="False"><input name="B" type="checkbox"/>B. The code will not compile because of line j1.</p>
                <p class="question-answer" data-is-correct="False"><input name="C" type="checkbox"/>C. The code will not compile because of line j2.</p>
                <p class="question-answer" data-is-correct="False"><input name="D" type="checkbox"/>D. The code will not compile because of line j3.</p>
                <p class="question-answer" data-is-correct="False"><input name="E" type="checkbox"/>E. It compiles but throws an exception at runtime.</p>
                <p class="question-answer" data-is-correct="True"><input name="F" type="checkbox"/>F. It compiles but waits forever at runtime.</p>
            </div>
            <p class="question-explanation">
                F. The code compiles without issue, so options B, C, and D are incorrect. The limit on the
                cyclic barrier is 10, but the stream can generate only up to 9 threads that reach the barrier;
                therefore, the limit can never be reached, and option F is the correct answer, making options
                A and E incorrect. Even if the limit(9) statement was changed to limit(10), the
                program could still hang since the JVM might not allocate 10 threads to the parallel stream.
            </p>
        </div>
        <div class="question" data-question="24">
            <h1 class="question-title">Question 24</h1>
            <p class="question-text">What statements about the following class definition are true? (Choose all that apply.)</p>
            <pre class="question-code">
public final class TicketManager {
  private int tickets;
  private static TicketManager instance;
  private TicketManager() {}
  static synchronized TicketManager getInstance() {      // k1
  if (instance==null) instance = new TicketManager(); // k2
    return instance;
  }
  public int getTicketCount() { return tickets; }
  public void addTickets(int value) {tickets += value;}  // k3
  public void sellTickets(int value) {
    synchronized (this) {                               // k4
    tickets -= value;
} } }
</pre>
            <div class="question-answers">
                <p class="question-answer" data-is-correct="True"><input name="A" type="checkbox"/>A. It compiles without issue.</p>
                <p class="question-answer" data-is-correct="False"><input name="B" type="checkbox"/>B. The code will not compile because of line k2.</p>
                <p class="question-answer" data-is-correct="False"><input name="C" type="checkbox"/>C. The code will not compile because of line k3.</p>
                <p class="question-answer" data-is-correct="False"><input name="D" type="checkbox"/>D. The locks acquired on k1 and k4 are on the same object.</p>
                <p class="question-answer" data-is-correct="False"><input name="E" type="checkbox"/>E. The class correctly protects the tickets data from race conditions.</p>
                <p class="question-answer" data-is-correct="True"><input name="F" type="checkbox"/>F. At most one instance of TicketManager will be created in an application that uses this class.</p>
            </div>
            <p class="question-explanation">
                A, F. The class compiles without issue, so option A is correct. Since getInstance() is a
                static method and sellTickets() is an instance method, lines k1 and k4 synchronize on different objects, making
                option D incorrect. The class is not thread-safe because the
                addTickets() method is not synchronized, and option E is incorrect. One thread could
                call sellTickets() while another thread calls addTickets(), possibly resulting in bad
                data. Finally, option F is correct because the getInstance() method is synchronized.
                Since the constructor is private, this method is the only way to create an instance of
                TicketManager outside the class. The first thread to enter the method will set the
                instance variable, and all other threads will use the existing value. This is a singleton
                pattern.
            </p>
        </div>
        <div class="question" data-question="25">
            <h1 class="question-title">Question 25</h1>
            <p class="question-text">Assuming an implementation of the performCount() method is provided prior to runtime, which of the following are possible
                results of executing the following application? (Choose all that apply.)</p>
            <pre class="question-code">
import java.util.*;
import java.util.concurrent.*;
public class CountZooAnimals {
public static void performCount(int animal) {
// IMPLEMENTATION OMITTED
}
public static void printResults(Future&lt;?&gt; f) {
      try {
         System.out.println(f.get(1, TimeUnit.DAYS)); // o1
      } catch (Exception e) {
         System.out.println("Exception!");
      }
   }
   public static void main(String[] args) throws Exception {
      final var r = new ArrayList&lt;Future&lt;?&gt;&gt;();
ExecutorService s = Executors.newSingleThreadExecutor();
try {
for(int i = 0; i &lt; 10; i++) {
final int animal = i;
r.add(s.submit(() -&gt; performCount(animal))); // o2
}
r.forEach(f -&gt; printResults(f));
} finally { s.shutdown(); }
} }
</pre>
            <div class="question-answers">
                <p class="question-answer" data-is-correct="False"><input name="A" type="checkbox"/>A. It outputs a number 10 times.</p>
                <p class="question-answer" data-is-correct="False"><input name="B" type="checkbox"/>B. It outputs a Boolean value 10 times.</p>
                <p class="question-answer" data-is-correct="True"><input name="C" type="checkbox"/>C. It outputs a null value 10 times.</p>
                <p class="question-answer" data-is-correct="True"><input name="D" type="checkbox"/>D. It outputs Exception! 10 times.</p>
                <p class="question-answer" data-is-correct="False"><input name="E" type="checkbox"/>E. It hangs indefinitely at runtime.</p>
                <p class="question-answer" data-is-correct="False"><input name="F" type="checkbox"/>F. The code will not compile because of line o1.</p>
                <p class="question-answer" data-is-correct="False"><input name="G" type="checkbox"/>G. The code will not compile because of line o2.</p>
            </div>
            <p class="question-explanation">
                C, D. The code compiles and runs without issue, so options F and G are incorrect. The return
                type of performCount() is void, so submit() is interpreted as being applied to a
                Runnable expression. While submit(Runnable) does return a Future&lt;?&gt;, calling
                get() on it always returns null. For this reason, options A and B are incorrect, and option
                C is correct. The performCount() method can also throw a runtime exception, which will
                then be thrown by the get() call as an ExecutionException; therefore, option D is also
                a correct answer. Finally, it is also possible for our performCount() to hang indefinitely,
                such as with a deadlock or infinite loop. Luckily, the call to get() includes a timeout value.
                While each call to Future.get() can wait up to a day for a result, it will eventually finish,
                so option E is incorrect.
            </p>
        </div>

        <p class="info"></p>
    </div>
    <div>
        <button type="button" class="start">Start</button>
        <button type="button" class="finish">Finish</button>
    </div>
</div>
<script src="script.js"></script>
</body>
</html>
